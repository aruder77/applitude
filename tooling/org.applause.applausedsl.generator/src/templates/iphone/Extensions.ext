import org::eclipse::emf::ecore;
import org::applause::applausedsl::applauseDsl;

extension org::eclipse::xtend::util::stdlib::io;
extension templates::MetamodelExtensions;


// Objective C language support: Imports
// While generating files, imports are collected in a list for header and module
// calling use() for String or ProjectClass adds the class to the list of imports

cached ProjectClass projectClass(String name):
	JAVA templates.Extensions.createProjectClass(java.lang.String);

String use(String name):
	use(projectClass(name));

String use(ProjectClass projectClass):
	JAVA templates.Extensions.use(org.applause.applausedsl.applauseDsl.ProjectClass);

Void useImportBag(Set[ProjectClass] bag):
	JAVA templates.Extensions.useImportBag(java.util.Set);

create Set[ProjectClass] bagHeaderImports (ProjectClass class):
	((List[ProjectClass]) {}).toSet();

create Set[ProjectClass] bagModuleImports (ProjectClass class):
	((List[ProjectClass]) {}).toSet();

Collection[ProjectClass] withoutBuiltIns(Collection[ProjectClass] classes):
	classes.reject(e|e.name.startsWith("UI") || e.name.startsWith("NS"));

List[ProjectClass] headerImports(ProjectClass class):
	class.bagHeaderImports().withoutBuiltIns().without({class}).sortBy(e|e.name);

List[ProjectClass] moduleImports(ProjectClass class):
	{class, class.bagModuleImports().withoutBuiltIns().without(class.bagHeaderImports()).without({class}).sortBy(e|e.name)}.flatten();

h(ProjectClass class):
	useImportBag(class.bagHeaderImports()) -> (class.name + ".h");

m(ProjectClass class):
	useImportBag(class.bagModuleImports()) -> (class.name + ".m");



// Objective C Method signatures and calls

// [target methodNameWithParam1:value1 param2:value2 ...] 
objc_Call(String target, String methodName, List[String] paramNames, List[String] paramValues):
	"[" + target + " " + methodName + paramNames.objc_MethodParamValues(paramValues) + "]";

// [target methodName] 
objc_Call(String target, String methodName):
	target.objc_Call(methodName, {}, {});

// [Class methodNameWithParam1:value1 param2:value2 ...] 
objc_Call(ProjectClass class, String methodName, List[String] paramNames, List[String] paramValues):
	objc_Call(use(class), methodName, paramNames, paramValues);

// [[Class alloc] initWithParam1:value2 param2:value2 ...]
objc_Init(ProjectClass class, List[String] paramNames, List[String] paramValues):
	("[" + use(class) + " alloc]").objc_Call("init", paramNames, paramValues);

// [[Class alloc] init]
objc_Init(ProjectClass class):
	class.objc_Init({}, {});

// [[[Class alloc] initWithParam1:value2 param2:value2 ...] autorelease]
objc_New(ProjectClass class, List[String] paramNames, List[String] paramValues):
	class.objc_Init(paramNames, paramValues).objc_Call("autorelease");

// [[[Class alloc] init] autorelease]
objc_New(ProjectClass class):
	class.objc_New({}, {});

// { "WithName1", "name2", ... }
objc_MethodParamNames(List[String] names):
	names.isEmpty ? {} : {"With" + names.first().toFirstUpper(), names.withoutFirst()}.flatten();

// WithName1:(Type1) name2:(Type2)name2 ...
objc_MethodParamSignatures(List[String] names, List[String] types):
	names.isEmpty ? "" :
		(let n = names.objc_MethodParamNames() :
					0.upTo(n.size - 1).collect(i|n.get(i)+ ":(" + types.get(i) + ")" + names.get(i)).toString(" "));

// WithName1:value1 name2:value2 ...
objc_MethodParamValues(List[String] names, List[String] values):
	names.isEmpty ? "" :
		(let n = names.objc_MethodParamNames() :
					0.upTo(n.size - 1).collect(i|n.get(i)+ ":" + values.get(i)).toString(" "));

// modifier (returnType) methodNameWithParam1:(Type1)param1 param2:(Type2)param2
objc_MethodSignature(ProjectClass class, String modifier, String methodName, String returnType, List[String] paramNames, List[String] paramTypes):
	modifier + " (" + returnType + ") " + methodName + paramNames.objc_MethodParamSignatures(paramTypes);




/* Mapping Model -> Objective-C class names */

class(View this):
	projectClass(this.name.toFirstUpper() + "ViewController");

class(CustomView this):
	this.projectClass;

class(Type this):
	projectClass(this.name);

class(TabView view):
	projectClass("UITabBarController");

class(ContentProviderImplementation this):
	"<Abstract " + this + ">";

class(UrlContentProviderImplementation this):
	projectClass("UrlContentProvider");

class(CustomContentProviderImplementation this):
	projectClass(this.providerClass.name);

viewFactory(Application app):
	projectClass(app.name + "Views");

providerFactory(Application app):
	projectClass(app.name + "Providers");

applicationDelegate(Application app):
	projectClass(app.name + "AppDelegate");


/* Views */

methodName(View view):
	"create" + view.name.toFirstUpper();

initSignature(View view):
	view.class().objc_MethodSignature(
		"-", "init", "id",
		view.parameters().name,
		view.parameterTypes());

init(View view, List[String] params):
	view.class().objc_Init(view.parameters().name, params);

callSignature(View view):
	view.class().objc_MethodSignature(
		"+", view.methodName(),
		view.class().use() + " *",
		view.parameters().name,
		view.parameterTypes());

call(ViewCall call):
	call.application().viewFactory().objc_Call(
		call.view.methodName(), 
		call.view.parameters().name,
		call.parameters().resolveToProvider());



/* Content Provider */

methodName(ContentProvider this):
	"providerFor" + name.toFirstUpper();

sharedProviders(Application this):
	"[" + providerFactory().use() + " sharedProviders]";

callSignature(ContentProvider this):
	application().providerFactory().objc_MethodSignature(
		"-", methodName(),
		use('ContentProvider') + " *",
		parameters().name,
		parameterTypes());

ivar(ContentProvider provider):
	"f" + provider.name.toFirstUpper();



/* Resolving expressions to a value */

resolveToValue(Void this):
	"nil";

resolveToValue(ScopeName this):
	this.ivar() + ".content";

resolveToValue(CollectionIterator this):
	this.name;

resolveToValue(Expression this):
	"<resolveToValue is abstract for: " + this + ">";

String replaceSettings(String string):
	JAVA templates.Extensions.replaceSettings(java.lang.String);

resolveToValue(StringLiteral this):
	this.value.replaceSettings();

resolveToValue(StringConcat this):
	'[NSString stringWithFormat:@"' 
		+ values.collect(e|"%@").toString("") + '", '
		+ values.resolveToValue().toString(", ") + "]";

resolveToValue(StringUrlConform this):
	'[' + value.resolveToValue() 
	    + ' stringByAddingPercentEscapesUsingEncoding:NSUTF8StringEncoding]';
	
resolveToValue(StringReplace this):
	'[' + value.resolveToValue() 
	    + ' stringByReplacingOccurrencesOfString:' + match.resolveToValue()
	    + ' withString:' + replacement.resolveToValue() + ']';

resolveToValue(StringSplit this):
	"[" + value.resolveToValue()
	    + " componentsSeparatedByString:"
	    + delimiter.resolveToValue() + "]";

resolveToValue(CollectionLiteral this):
	'[NSArray arrayWithObjects:' + items.collect(e|e.resolveToValue()).toString(", ") + ", nil]";

resolveToValue(ObjectReference this):
	tail == null ? this.object.resolveToValue()
	             : ( '[' + this.object.resolveToValue() 
	                     + ' valueFor' + ((tail.keyPath().size > 1) ? 'KeyPath:' : 'Key:')
	                     + tail.objcKeyPath() + ']' );



/* Resolving expressions to a content provider */

resolveToProvider(ScopeName this):
	this.ivar();

resolveToProvider(CollectionIterator this):
	'[' + use('SimpleContentProvider') + ' providerWithContent:' + this.name + ' name:@"' + this.name + '"]';
	
resolveToProvider(Expression this):
	'[' + use('SimpleContentProvider') + ' providerWithContent:' + this.resolveToValue() + ' name:@""]';

resolveToProvider(ProviderConstruction this): // TODO: rename to ProviderCall?
	"<resolveToProvider is abstract for: " + this + ">";

resolveToProvider(SimpleProviderConstruction this): // TODO: ProviderReference?
	this.expression.resolveToProvider();

// TODO: ComplexProviderConstruction.provider, ViewCall.view are similar -> check similar naming conventions for both

resolveToProvider(ComplexProviderConstruction this): // TODO: ProviderConstructionCall?
	application().sharedProviders().objc_Call(
		provider.methodName(),
		provider.parameters().name,
		parameterValues().resolveToProvider()
	);

resolveToProvider(ObjectReference this):
	this.tail == null
		? object.resolveToProvider()
		: ("ContentProvider+Nested".use() -> 'ContentProvider'.objc_Call(
				'nestedContentProvider',
				{ 'contentProvider', 'keyPath' },
				{ object.resolveToProvider(), tail.objcKeyPath() }));



/* Assigning expression values to variables */

assignment(Void this, String targetObject, String targetProperty):
	'';

assignment(ScalarExpression this, String targetObject, String targetProperty):
	targetObject + "." + targetProperty + " = " + resolveToValue() + ";";

assignment(Binding this, String targetObject, String targetProperty):
	'[fBindings bind:' + target.object.resolveToProvider() + ' property:@"content.' + target.tail.keyPath().toString('.') + '" to:' + targetObject + ' property:@"' + targetProperty + '"];';



/* TableView */

constant(TableViewStyle style):
	"UITableViewStyle" + style.name;

constant(CellType type):
	"UITableViewCellStyle" + type.literal;

constant(CellAccessory ac):
	switch(ac.name) {
		case 'Link' : 'UITableViewCellAccessoryDisclosureIndicator'
		case 'Detail' : 'UITableViewCellAccessoryDetailDisclosureButton'
		case 'Check' : 'UITableViewCellAccessoryCheckmark'
		default : 'UITableViewCellAccessoryNone'
	};

index(EObject obj, xpand2::Type type):
	obj.eContainer().eContents().select(e|type.isInstance(e)).indexOf(obj) + 1;

idname(StringLiteral str):
	str.value.split(" ").toFirstUpper().toString("").toFirstLower().replaceAll("[^a-zA-Z]", "");

// unique id for cell: cell.iterator or cell.text or section/cell index 
idname(Cell cell):
	cell.iterator != null
		? cell.iterator.name
		: (StringLiteral.isInstance(cell.text)
			? ((StringLiteral)cell.text).idname()
			: ('s' + cell.eContainer().index(Section) + 'c' + cell.index(Cell)));

providers(TableView view):
	{ view.parameters(), view.variables }.flatten();



/* TableView: Section and Cell */

cellClass(Cell cell):
	cell.image != null ? use('ImageCell') : use('BoxCell');

String shortName(ViewContentElement this):
	Cell.isInstance(this) ? "cell" : "section";

String targetType(ViewContentElement this):
	Cell.isInstance(this) ? use("UITableViewCell") : use("Section");

String objcConstruct(ViewContentElement this):
	"<objcConstruct is abstract for: " + this + ">";

objcConstruct(Cell cell):
	 cell.cellClass() + ' *cell = [[[' + cell.cellClass() + ' alloc] initWithStyle:' + cell.type.constant() + " reuseIdentifier:nil] autorelease];\n"
	 + cell.text.assignment('cell.textLabel', 'text')
	 + cell.detailText.assignment('cell.detailTextLabel', 'text')
	 + cell.image.assignment('cell', 'imageUrl')
	 + ((cell.accessory.ordinal() == 0 && cell.action != null) ? 'cell.accessoryType = UITableViewCellAccessoryDisclosureIndicator;\n' : "")
	 + ((cell.accessory.ordinal() > 0) ? 'cell.accessoryType = ' + cell.accessory.constant() + ";\n" : "")
	 + ((cell.action != null) ? 'cell.onTouch = ' + action(cell.action, cell) + ";\n" : "")
	 + ((cell.iterator != null) ? 'cell.data = ' + cell.iterator.resolveToValue() + ';\n' : "[self cell:cell];\n");

objcConstruct(Section section):
	(section.iterator != null ? use('Section') + " *section = " : "") 
	 + '[self section' + (section.title == null ? '' : 'WithTitle:' + section.title.resolveToValue()) + '];\n'
	 + section.cells.objcSetup().toString("\n");

objcConstructPlaceholder(ViewContentElement e):
	"[self " + e.shortName() + "s:@selector(" + e.iterator.name + e.shortName().toFirstUpper() + ":) " +
				((Section.isInstance(e.eContainer()) && ((Section)(e.eContainer())).iterator != null)
					? ("forList:" + e.iterator.collection.resolveToValue())
					: ("forContentProvider:" + e.iterator.collection.resolveToProvider())
				) + "];";

objcSetup(ViewContentElement this):
	 let code = (iterator != null ? objcConstructPlaceholder() : objcConstruct())
	          : Cell.isInstance(this) ? "{\n" + code + "\n}\n" : code; 



/* Actions */

//TOOD: cell is handed in to calculate unique cell selector name for ViewCall - there has to be a better way
action(ViewAction this, Cell cell):
	throwError("action not supported for " + this);

action(ViewCall call, Cell cell):
	'[' + "SelectorAction".use() + ' actionWithObject:self selector:@selector(' + cell.idname() + 'CellSelected:)]';

action(Selector sel, Cell cell):
	'[' + "SelectorAction".use() + ' actionWithObject:self selector:@selector(' + sel.name + ')]';




/* Parameter handling */

// simulates parameter list, at the moment there can be only 0/1 parameters
// remove with http://ralfebert.lighthouseapp.com/projects/67904/tickets/57-support-for-multiple-parameters
List[Parameter] parameters(View this):
	{ parameter }.remove(null);

List[Parameter] parameters(ContentProvider this):
	{ parameter }.remove(null);

List[Parameter] parameterTypes(View view):
	view.parameters().collect(e|"ContentProvider".use() + " *");

List[Parameter] parameterTypes(ContentProvider this):
	parameters().collect(e|"ContentProvider".use() + " *");

List[ProviderConstruction] parameters(ViewCall view):
	{ view.parameter }.remove(null);

//TODO: parameters vs. argument vs. parameterValues(Bindings?)

List[Expression] parameterValues(ComplexProviderConstruction this):
	{ this.argument }.remove(null);




/* Misc */

objcType(Type this):
	throwError("<objcType not supported for " + this + ">");

objcType(SimpleType type):
	type.platformType + " *";

objcType(Entity type):
	type.runtimeType ? type.name + " *" : "id";

variable(Type this, String name):
	this.objcType() + (this.objcType().endsWith("*") ? "" : " ") + name;

type(ScopeName param):
	'ContentProvider'.use() + " *";

ivar(ScopeName param):
	"f" + param.name.toFirstUpper();
	
Boolean hasBindings(EObject this):
	Binding.isInstance(this) || this.eContents().exists(e|((EObject)e).hasBindings());

List[String] keyPath(ObjectReference this):
	tail == null ? {object.name} : {object.name}.addAll(tail.keyPath());

objcKeyPath(ObjectReference this):
	'@"' + keyPath().toString(".") + '"';



/* Application */

allProviders(Application this):
	model().elements.typeSelect(ContentProvider);
	
allViews(Application this):
	model().elements.typeSelect(View);